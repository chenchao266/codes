#include	"unp.h"
#include	<net/if.h>			/* if_msghdr{} */
#include	<net/if_dl.h>		/* sockaddr_sdl{} */
#include	<net/route.h>		/* RTA_xxx constants */
#include	<sys/param.h>
#ifndef 	RTAX_MAX

#define RTM_ADD	     0x1    /* Add Route */
#define RTM_DELETE	     0x2    /* Delete Route */
#define RTM_CHANGE	     0x3    /* Change Metrics, Flags, or Gateway */
#define RTM_GET	     0x4    /* Report Information */
#define RTM_LOSING	     0x5    /* Kernel Suspects Partitioning */
#define RTM_REDIRECT    0x6    /* Told to use different route */
#define RTM_MISS	     0x7    /* Lookup failed on	this address */
#define RTM_RESOLVE     0xb    /* request to resolve dst to LL addr */
#define RTM_NEWADDR     0xc    /* address being added to iface */
#define RTM_DELADDR     0xd    /* address being removed from iface	*/
#define RTM_OOIFINFO    0xe    /* Old (pre-1.5) RTM_IFINFO	message	*/
#define RTM_OIFINFO     0xf    /* Old (pre-6.0) RTM_IFINFO	message	*/
#define RTM_IFANNOUNCE  0x10   /* iface arrival/departure */
#define RTM_IFINFO	     0x14   /* iface/link going	up/down	etc. */
#define RTM_CHGADDR     0x15   /* address has changed on iface */

#define RTAX_DST	0	/* destination sockaddr present */
#define RTAX_GATEWAY	1	/* gateway sockaddr present */
#define RTAX_NETMASK	2	/* netmask sockaddr present */
#define RTAX_GENMASK	3	/* cloning mask sockaddr present */
#define RTAX_IFP	4	/* interface name sockaddr present */
#define RTAX_IFA	5	/* interface addr sockaddr present */
#define RTAX_AUTHOR	6	/* sockaddr for author of redirect */
#define RTAX_BRD	7	/* for NEWADDR, broadcast or p-p dest addr */
#define RTAX_MAX	8	/* size of array to allocate */

#define NET_RT_DUMP	1		/* dump; may limit to a.f. */
#define NET_RT_FLAGS	2		/* by flags, e.g. RESOLVING */
#define NET_RT_IFLIST	3		/* survey interface list */
#define NET_RT_MAXID	4

#define RTA_DST	   0x1	  /* destination sockaddr present */
#define RTA_GATEWAY   0x2	  /* gateway sockaddr present */
#define RTA_NETMASK   0x4	  /* netmask sockaddr present */
#define RTA_GENMASK   0x8	  /* cloning mask sockaddr present */
#define RTA_IFP	   0x10	  /* interface name sockaddr present */
#define RTA_IFA	   0x20	  /* interface addr sockaddr present */
#define RTA_AUTHOR	   0x40	  /* sockaddr for author of redirect */
#define RTA_BRD	   0x80	  /* for NEWADDR, broadcast or p-p dest	addr */
#define RTA_TAG	   0x100  /* route tag */

#define	RTF_UP		0x1		/* route useable */
#define	RTF_GATEWAY	0x2		/* destination is a gateway */
#define	RTF_HOST	0x4		/* host entry (net otherwise) */
#define	RTF_REJECT	0x8		/* host or net unreachable */
#define	RTF_DYNAMIC	0x10		/* created dynamically (by redirect) */
#define	RTF_MODIFIED	0x20		/* modified dynamically (by redirect) */
#define RTF_DONE	0x40		/* message confirmed */
#define RTF_MASK	0x80		/* subnet mask present */
#define RTF_CLONING	0x100		/* generate new routes on use */
#define RTF_XRESOLVE	0x200		/* external daemon resolves name */
#define RTF_LLINFO	0x400		/* generated by ARP or ESIS */
#define RTF_PROTO2	0x4000		/* protocol specific routing flag */
#define RTF_PROTO1	0x8000		/* protocol specific routing flag */

struct	if_data {
	/* generic interface information */
	u_char	ifi_type;	/* ethernet, tokenring, etc */
	u_char	ifi_addrlen;	/* media address length */
	u_char	ifi_hdrlen;	/* media header length */
	u_long	ifi_mtu;	/* maximum transmission unit */
	u_long	ifi_metric;	/* routing metric (external only) */
	u_long	ifi_baudrate;	/* linespeed */
	/* volatile statistics */
	u_long	ifi_ipackets;	/* packets received on interface */
	u_long	ifi_ierrors;	/* input errors on interface */
	u_long	ifi_opackets;	/* packets sent on interface */
	u_long	ifi_oerrors;	/* output errors on interface */
	u_long	ifi_collisions;	/* collisions on csma interfaces */
	u_long	ifi_ibytes;	/* total number of octets received */
	u_long	ifi_obytes;	/* total number of octets sent */
	u_long	ifi_imcasts;	/* packets received via multicast */
	u_long	ifi_omcasts;	/* packets sent via multicast */
	u_long	ifi_iqdrops;	/* dropped on input, this interface */
	u_long	ifi_noproto;	/* destined for unsupported protocol */
	struct	timeval ifi_lastchange;/* last updated */
};

struct rt_metrics {
	u_long	rmx_locks;	    /* Kernel must leave these values alone */
	u_long	rmx_mtu;	    /* MTU for this path */
	u_long	rmx_hopcount;	    /* max hops	expected */
	u_long	rmx_expire;	    /* lifetime	for route, e.g.	redirect */
	u_long	rmx_recvpipe;	    /* inbound delay-bandwidth product */
	u_long	rmx_sendpipe;	    /* outbound	delay-bandwidth	product	*/
	u_long	rmx_ssthresh;	    /* outbound	gateway	buffer limit */
	u_long	rmx_rtt;	    /* estimated round trip time */
	u_long	rmx_rttvar;	    /* estimated rtt variance */
	u_long	rmx_pksent;	    /* packets sent using this route */
};

struct rt_msghdr {
	u_short rtm_msglen;	    /* to skip over non-understood messages */
	u_char	 rtm_version;	    /* future binary compatibility */
	u_char	 rtm_type;	    /* message type */
	u_short rtm_index;	    /* index for associated ifp	*/
	int	 rtm_flags;	    /* flags, incl kern	& message, e.g.	DONE */
	int	 rtm_addrs;	    /* bitmask identifying sockaddrs in	msg */
	pid_t	 rtm_pid;	    /* identify	sender */
	int	 rtm_seq;	    /* for sender to identify action */
	int	 rtm_errno;	    /* why failed */
	int	 rtm_use;	    /* from rtentry */
	u_long	 rtm_inits;	    /* which metrics we	are initializing */
	struct	 rt_metrics rtm_rmx; /*	metrics	themselves */
};

struct if_msghdr {
	u_short ifm_msglen;	    /* to skip over non-understood messages */
	u_char	 ifm_version;	    /* future binary compatibility */
	u_char	 ifm_type;	    /* message type */
	int	 ifm_addrs;	    /* like rtm_addrs */
	int	 ifm_flags;	    /* value of	if_flags */
	u_short ifm_index;	    /* index for associated ifp	*/
	struct	 if_data ifm_data;  /* statistics and other data about if */
};

struct ifa_msghdr {
	u_short ifam_msglen;	    /* to skip over non-understood messages */
	u_char	 ifam_version;	    /* future binary compatibility */
	u_char	 ifam_type;	    /* message type */
	int	 ifam_addrs;	    /* like rtm_addrs */
	int	 ifam_flags;	    /* value of	ifa_flags */
	u_short ifam_index;	    /* index for associated ifp	*/
	int	 ifam_metric;	    /* value of	ifa_metric */
};

struct if_announcemsghdr {
	u_short ifan_msglen;	    /* to skip over non-understood messages */
	u_char	 ifan_version;	    /* future binary compatibility */
	u_char	 ifan_type;	    /* message type */
	u_short ifan_index;	    /* index for associated ifp	*/
	char	 ifan_name[IFNAMSIZ]; /* if name, e.g. "en0" */
	u_short ifan_what;	    /* what type of announcement */
};




#endif
#ifdef	HAVE_SYS_SYSCTL_H
#include	<sys/sysctl.h>		/* sysctl() */
#endif

			/* function prototypes */
void	 get_rtaddrs(int, struct sockaddr *, struct sockaddr **);
char	*net_rt_iflist(int, int, size_t *);
char	*net_rt_dump(int, int, size_t *);
const char	*sock_masktop(struct sockaddr *, socklen_t);

			/* wrapper functions */
char	*Net_rt_iflist(int, int, size_t *);
char	*Net_rt_dump(int, int, size_t *);
#define	Sock_masktop(a,b)		sock_masktop((a), (b))

/*
#ifdef AF_LINK
#   include <net/if_dl.h>
#endif
#ifdef AF_PACKET
#   include <netpacket/packet.h>
#endif


#ifdef AF_LINK
    #define SDL ((struct sockaddr_dl *)ifa->ifa_addr)
    if (SDL->sdl_family == AF_LINK) {
        bcopy(SDL->sdl_data + SDL->sdl_nlen,....,SDL->sdl_alen
    }
    #undef SDL
#endif
#ifdef AF_PACKET
    if (ifa->ifa_addr->sa_family == AF_PACKET) {
        struct sockaddr_ll *sl = 
            (struct sockaddr_ll*) ifa->ifa_addr;

        bcopy(sl->sll_addr,....,sl->sll_halen
    }
#endif  
*/
